// Bitcore classes
var bitcore           = require('bitcore');
var networks          = bitcore.networks;
var coinUtil          = bitcore.util;
var Block             = bitcore.Block;
var Address           = bitcore.Address;
var Script            = bitcore.Script;
var Peer              = bitcore.Peer;
var Transaction       = bitcore.Transaction
var TransactionIn     = Transaction.In;
var TransactionOut    = Transaction.Out;

var network = networks.maxcoin;

var PeerManager = require('soop').load('bitcore/PeerManager', {
  network: network
});

// database ORM
var Sequelize = require('sequelize');

var sequelize = new Sequelize('maxwallet', 'postgres', 'Compost12!', {
  host: 'localhost',
  dialect: 'postgres',
  port: 5432,
});

// validation functions
var isValidAddress = function(value) {
  /*var addr = new Address(value);
  if (!addr.isValid()) {
    throw new Error('invalid address');
  }*/
  // TODO
}

var isValidScript = function(value) {
  var script = new Script(value);
}

// database models
var tableTx = sequelize.define('tx_Main', {
  // txid, confirmed on the blockchain
  txid: {
    type: Sequelize.STRING,
    allowNull: false,
    validate: {
      isAlphanumeric: true,
      notEmpty: true,
      len: [64],
    }
  },
  // txid, generated by the transaction
  // used to detect malleability
  generatedTxid: {
    type: Sequelize.STRING,
    allowNull: true,
    validate: {
      isAlphanumeric: true,
      notEmpty: true,
      len: [64],
    }
  },
  confirmations: {
    type: Sequelize.INTEGER,
    allowNull: false,
    defaultValue: 0,
    validate: {
      min: 0
    }
  },
  blockHash: {
    type: Sequelize.STRING,
    allowNull: false, 
    validate: {
      isAlphanumeric: true,
      notEmpty: true,
      len: [64],
    }
  },
  timestamp: Sequelize.DATE,
});

var tableTxUser = sequelize.define('tx_User', {
  uid: Sequelize.INTEGER,
  tid: Sequelize.INTEGER,
  type: Sequelize.ENUM('sent', 'received', 'mined'),
});
tableTx.hasMany(tableTxUser);
//tableUser.hasMany(tableTxUser);

var tableTxInput = sequelize.define('tx_Input', {
  tid: Sequelize.INTEGER,
  txid: {
    type: Sequelize.STRING,
    allowNull: false,
    validate: {
      isAlphanumeric: true,
      notEmpty: true,
      len: [64],
    }
  },
  address: {
    type: Sequelize.STRING,
    allowNull: false,
    validate: {
      isAddress: isValidAddress,
    }
  }
});
tableTx.hasMany(tableTxInput);

var tableTxOutput = sequelize.define('tx_Output', {
  tid: Sequelize.INTEGER,
  address: {
    type: Sequelize.STRING,
    allowNull: false,
    validate: {
      isAddress: isValidAddress
    }
  },
  value: {
    type: Sequelize.INTEGER,
    allowNull: false,
    validate: {
      min: 0,
      max: network.maxMoney,
    }
  },
  script: {
    type: Sequelize.TEXT,
    allowNull: false,
    validate: {
      isScript: isValidScript
    }
  },
});
tableTx.hasMany(tableTxOutput);

var tableAddress = sequelize.define('Address', {
  uid: Sequelize.INTEGER,
  address: {
    type: Sequelize.STRING,
    allowNull: false,
    validate: {
      isAddress: isValidAddress
    }
  },
});
//tableUser.hasMany(tableAddress);

// get an address from scriptPubKey
var getAddrStr = function(s) {
  var addrStrs = [];
  var type = s.classify();
  var addr;

  switch (type) {
    case Script.TX_PUBKEY:
      var chunk = s.captureOne();
      addr = new Address(network.addressPubkey, coinUtil.namedHash(network.addressHash, chunk));
      addrStrs.push(addr.toString());
      break;
    case Script.TX_PUBKEYHASH:
      addr = new Address(network.addressPubkey, s.captureOne());
      addrStrs.push(addr.toString());
      break;
    case Script.TX_SCRIPTHASH:
      addr = new Address(network.addressScript, s.captureOne());
      addrStrs.push(addr.toString());
      break;
    case Script.TX_MULTISIG:
      var chunks = s.capture();
      chunks.forEach(function(chunk) {
        var a = new Address(network.addressPubkey, coinUtil.namedHash(network.addressHash, chunk));
        addrStrs.push(a.toString());
      });
      break;
    case Script.TX_UNKNOWN:
      console.log('tx type unknown');
      break;
  }
  return addrStrs;
};

// convert a value string to readable form
var readableValue = function(value) {
  return value / 100000000;
}

// callback function for when a p2p connection is established
var handleConnect = function(data) {
  var peerman = data.pm;
  console.log('[Connection] connected to ' + peerman.peers.length + ' peer' + (peerman.peers.length !== 1 ? 's': ''));
};

// callback function when a new block is received
var handleBlock = function(info) {
  var blk = new Block(info.message.block);

  // block hash
  var blkHash = coinUtil.formatHashFull(blk.calcHash())
  console.log('[Connection] received block: %s', blkHash);

  // extract hashes from txs
  var txHashes = blk.txs.map(function(tx) {
    return coinUtil.formatHashFull(tx.hash);
  });

  // extract addresses from txs
  for (var i in blk.txs) {
    var tx = blk.txs[i];
    var txStandarized = tx.getStandardizedObject();
    //console.log(txStandarized);

    // TODO - verify transaction
    // for now we only connect to a local daemon
    // and assume it's trustworthy.

    // find any tracked addresses
    var addresses = [];

    for (var j in tx.ins) {
      if (!tx.isCoinBase()) {
        var scriptSig = txStandarized.in[j].scriptSig;
        var pubkey = new Buffer(scriptSig.split(' ')[1].slice(2), 'hex');
        var inputAddr = new Address(network.addressPubkey, coinUtil.namedHash(network.hashes.addrHash, pubkey));
        addresses.push(inputAddr.toString());
      }
    } // end of tx.ins

    for (var j in tx.outs) {
      var outtx = new TransactionOut(tx.outs[j]);
      var scriptPubKey = outtx.getScript();
      var addrs = getAddrStr(scriptPubKey);

      // ensure transaction type is supported
      // TODO - improve this for multisig txs
      if (addrs.length > 1) {
        console.log('[Connection] cannot handle multiple addresses','tx',txHashes[i],'output index',j);
        throw new Error("Could not handle transaction ouputs with multiple addresses");
      };

      addresses.push(addrs[0]);
    } // end of tx.outs

    // are any of the addresses within the tx tracked?
    tableAddress.findAll({ where: { address: addresses } }).success(function(knownAddresses) {
      if (knownAddresses.length > 0) {
        // set the date variable
        var date = new Date();

        // look for matching transactions in our database
        tableTx.findAll({where: { txid: txHashes[i]}}).success(function(retrievedTxs) {
          if (retrievedTxs.length > 0) {
            // check for duplicated txids
            // possible due to a quirk in the protocol
            if (retrievedTxs.length > 1) {
              console.log('Duplicate txid found',txHashes[i]);
              return;
            }

            // TODO - increment confirmations
            //tableTx.find().increment().success(function(res) {
            //});
            console.log('TODO','increment confirmations');
            return;
          }

          // TODO - check for similar transactions
          // this can be done by examining the scripts and the amounts
          // inside a tx, and checking the timestamp
          // if it's close to that of a transaction we have just made
          // we assume foul-play (malleability exploit)
          // TODO - IMPROVEMENT - check for modified PUSH_DATA opcodes
          // update to set txid to confirmed txid

          // create a new database entry
          var txQuery = {
            txid: txHashes[i],
            generatedTxid: null, 
            blockHash: blkHash,
            timestamp: date.getTime(),
          };

          sequelize.sync({ force: false }).complete(function(err) {
            tableTx.create(txQuery).complete(function(err, tx) {
              if (err) {
                console.log('Error creating tx',err);
                return;
              }
              console.log('created tx');
            });
          });
        });

        // TODO - add the input and output txs
        // inputs
        for (var j in tx.ins) {
          var intx = new TransactionIn(tx.ins[j]);
          //console.log('intx', intx);

          // regular transaction?
          // coinbase transactions don't have inputs
          if (!intx.isCoinBase()) {
            // extract the scriptSig
            // <sig> <pubkey>
            var scriptSig = txStandarized.in[j].scriptSig;

            // TODO - if there are loads of inputs, this can screw up.
            //console.log(scriptSig);

            // extract the input address
            var pubkey = new Buffer(scriptSig.split(' ')[1].slice(2), 'hex');
            var inputAddr = new Address(network.addressPubkey, coinUtil.namedHash(network.hashes.addrHash, pubkey));
            //console.log('input address',inputAddr.toString());

            // extract output tx
            var prevOut = txStandarized.in[j].prev_out;
            //console.log('input txid',prevOut.hash);

            // do we care about this address?
            tableAddress.find({where: { address: inputAddr.toString() }}).complete(function(err, retrievedAddress) {
              if (err) {
                console.log('Error retrieving address',err);
                return;
              }

              if (retrievedAddress) {
                console.log('Transaction does exist in database!');
              }
            });

            // create a sample query
            var txInputQuery = {
              tid: 'TODO - transaction id',
              address: inputAddr.toString(),
              txid: prevOut,
            };
          }
        }

        // outputs
        for (var j in tx.outs) {
          var outtx = new TransactionOut(tx.outs[j]);
          //console.log('outtx', outtx);

          // extract the address
          var scriptPubKey = outtx.getScript();
          var addrs = getAddrStr(scriptPubKey);

          // ensure transaction type is supported
          // TODO - improve this for multisig txs
          if (addrs.length > 1) {
            console.log('[Connection] cannot handle multiple addresses','tx',txHashes[i],'output index',j);
            throw new Error("Could not handle transaction ouputs with multiple addresses");
          }

          //console.log('send',readableValue(outtx.getValue()),'MAX','to',addrs[0]);

          // TODO - IF addrs[0] IS IN OUR DATABASE
          var type = (tx.isCoinBase()) ? 'mining' : 'receive';
          var uid = 'SELECT * FROM user, address WHERE user.uid = address.uid AND address.address = ' + addrs[0];

          var txUserQuery = {
            uid: 'TODO - user id foreign key', // uid
            tid: 'TODO - transaction id',
            type: type,
          };

          var txOutputQuery = {
            tid: 'TODO - transaction id',
            address: addrs[0],
            value: outtx.getValue(),
            script: txStandarized.out[j].scriptPubKey,
          };
        }

        // TOOD - add the user txs
      }
    }); // end of tableAddress.findAll
  } // end of blk.txs
}; // end of handleBlock

// callback function when a new transaction is received
var handleTx = function(info) {
  var tx = info.message.tx.getStandardizedObject();
  //console.log('[Connection] received tx: %s', tx.hash);
}

// callback function for when a new inventory
// message is received
var handleInv = function(info) {
  // handle message by referring to other callbacks
  var invs = info.message.invs;
  info.conn.sendGetData(invs);
};

// callback function for when a submitted tx is
// rejected by a peer
var handleReject = function(info) {
  console.log('[Connection] submitted transaction was rejected');
}

// send a tx to peers
var sendTx = function(tx) {
  var conn = peerman.getActiveConnection();
  if (conn) {
    conn.sendTx(tx);
  }
}


var createTx = function(value) {
  // INPUT TX OF COINS TO SPEND
  var TXIN = 'd05f35e0bbc495f6dcab03e599c8f5e32a07cdb4bc76964de201d06a2a7d8265';
  // NUMBER OF TX INPUTS????????????????????????????????????
  var TXIN_N = 0;
  // ADDRESS TO SEND TO
  var ADDR = 'mPQERLaEVcj1cMSMX5tyCcCdBeZCkm6GEK';
  // VALUE OF TRANSACTION
  var VAL = '0.001';

  // set up object to populate
  var txobj = {
    version: 1,
    lock_time: 0,
    ins: [],
    outs: []
  };

  // add inputs
  var txin = {
    s: coinUtil.EMPTY_BUFFER, // TODO - SIGNATURE HERE
    q: 0xffffffff
  };

  var hash = new Buffer(TXIN.split('').reverse(), 'hex');
  var vout = parseInt(TXIN_N);
  var voutBuf = new Buffer(4);

  voutBuf.writeUInt32LE(vout, 0);
  txin.o = Buffer.concat([hash, voutBuf]);
  txobj.ins.push(txin);

  var addr = new Address(ADDR);
  var script = Script.createPubKeyHashOut(addr.payload());
  var valueNum = coinUtil.parseValue(VAL);
  var value = coinUtil.bigIntToValue(valueNum);

  var txout = {
    v: value,
    s: script.getBuffer(),
  };
  txobj.outs.push(txout);

  return new Transaction(txobj);
}

// set up the p2p connection to the network
var peerman = new PeerManager();
//peerman.addPeer(new Peer('127.0.0.1', 8333)); // BITCOIN
peerman.addPeer(new Peer('127.0.0.1', 8668)); // MAXCOIN

// set up callback functions
// ref: https://en.bitcoin.it/wiki/Protocol_specification
peerman.on('connect', handleConnect);
peerman.on('connection', function(conn) {
  conn.on('inv', handleInv); // inventory message
  conn.on('block', handleBlock); // new block
  conn.on('tx', handleTx); // transaction received
  conn.on('reject', handleReject); // transaction rejected
});

peerman.start();
